<!DOCTYPE html><html lang="en"><head><title>Paradigm Shift | Comp Form</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-41378785-2"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-41378785-2');</script><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><!-- open graph--><meta property="og:site_name" content="compform.net"><meta property="og:title" content="Paradigm Shift"><meta property="og:description" content="Shaders draw in a fundamentally different way than serial shaper rasterizers like the WebGL Canvas API or the Processing graphics API. This difference allows shaders to draw very quickly, but requires a new way of thinking when programming."><meta property="og:image"><meta name="twitter:card" content="summary_large_image"><link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32"><link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16"><!-- jquery--><script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script><!-- bootstrap--><script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.11.0/umd/popper.min.js" integrity="sha384-b/U6ypiBEHpOf/4+1nzFpr53nxSS+GLCkfwBdFNTxtclqqenISfwAzpKaMNFNmj4" crossorigin="anonymous"></script><link rel="stylesheet" href="/vendor/bootstrap/css/bootstrap.min.css" integrity="sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M" crossorigin="anonymous"><script src="/vendor/bootstrap/js/bootstrap.min.js" integrity="sha384-h0AbiXch4ZDo7tp9hKZ4TsHbi047NrKGLO3SEJAg45jXxnGIfYzk4Si90RDIqNm1" crossorigin="anonymous"></script><!-- font awesome--><link rel="stylesheet" href="/vendor/font-awesome/css/font-awesome.min.css"><!-- syntax hilighting--><link rel="stylesheet" href="/vendor/highlightjs/css/atom-one-dark.css"><!-- styles--><link rel="stylesheet" href="/src/styles.css"><!--scripts--><script src="/src/bundle.js"></script></head><body class="comp-form"><div id="logo"><a href="/"><svg width="20px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 128 128" style="enable-background:new 0 0 128 128;" xml:space="preserve">
<polygon points="32,64 0,119.4 64,119.4"/>
<polygon points="64,8.6 32,64 96,64"/>
<polygon points="80,91.7 64,119.4 96,119.4"/>
<polygon points="112,91.7 96,119.4 128,119.4"/>
<polygon points="96,64 80,91.7 112,91.7"/>
</svg></a></div><header class="container" id="top-nav"><div class="row justify-content-md-center"><div class="col-md-8"><span class="title">Thinking in Shaders</span><div class="buttons"></div></div></div></header><div id="content"><div class="container" id="hero"><div class="row justify-content-md-center"><div class="col-md-8"><h1>Thinking in Shaders</h1><h6>Overview</h6><p class="description">Shaders draw in a fundamentally different way than serial shaper rasterizers like the WebGL Canvas API or the Processing graphics API. This difference allows shaders to draw very quickly, but requires a new way of thinking when programming.</p><h6>Tools</h6><p class="software">ShaderToy + glslCanvas</p></div></div></div><div class="container" id="copy"><div class="row justify-content-md-center"><div class="col-md-8 comp-form-copy"><h2 id="a-paradigm-shift">A Paradigm Shift</h2>
<p>The CPU—central processing unit—executes the instructions in computer programs. CPU architecutres are designed to be general. They run a wide variety of programs pretty quickly. The GPU-graphics processing unit-also executes computer programs. GPU architectures are specifically designed to address parallelizable problems. They can execute these types of problems extremely quickly, but aren’t as well suited serial problems.</p>
<p>Shaders are programs that run on a GPU, often as part of a 3D graphics pipeline. Because the architectures of GPUs and CPUs have different affordances, shader programs have different strengths and limitations. When programming shaders you will often have to think about problems in a entirely new ways.</p>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.16/p5.min.js"></script>
<script src="../mess/faces_mess.js"></script> -->
<div id="" class="activity">
<h2 id="serial-vs-parallel">Serial vs Parallel</h2>
<p>Working in large groups, complete the following tasks as quickly as possible without making any mistakes.</p>
<h3 id="task-1">Task 1</h3>
<p><strong>Calculate the first 25 <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a>.</strong></p>
<p>The Fibonacci numbers are a sequence of integers in which each integer is the sum of the previous two, starting with 0 and 1.</p>
<pre><code class="language-javascript"><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, ...
</code></pre>
<p>One way to describe the Fibonacci sequence is with this set of recursive rules.</p>
<pre><code class="language-javascript">F(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>, F(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>, F(n) = F(n<span class="hljs-number">-1</span>) + F(n<span class="hljs-number">-2</span>)
</code></pre>
<h3 id="task-2">Task 2</h3>
<p><strong>Calculate the following 25 expressions.</strong></p>
<div id="" class="headless">
<table class="table table-responsive">
<thead>
<tr>
<th>a</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
</tr>
</thead>
<tbody>
<tr>
<td>68 * 89</td>
<td>86 * 43</td>
<td>30 * 11</td>
<td>88 * 13</td>
<td>72 * 53</td>
</tr>
<tr>
<td>83 * 85</td>
<td>14 * 32</td>
<td>92 * 26</td>
<td>93 * 35</td>
<td>13 * 85</td>
</tr>
<tr>
<td>15 * 93</td>
<td>13 * 51</td>
<td>43 * 74</td>
<td>98 * 60</td>
<td>44 * 69</td>
</tr>
<tr>
<td>61 * 54</td>
<td>55 * 19</td>
<td>24 * 16</td>
<td>11 * 70</td>
<td>11 * 36</td>
</tr>
<tr>
<td>25 * 16</td>
<td>19 * 23</td>
<td>83 * 34</td>
<td>42 * 47</td>
<td>24 * 11</td>
</tr>
</tbody>
</table>
</div>
<h3 id="discussion">Discussion</h3>
<ul>
<li>Did working in a group make Task 1 faster?</li>
<li>Did working in a group make Task 2 faster?</li>
<li>Which task required more difficult arithmetic?</li>
<li>How did your group approach these two problems?</li>
<li>Would using other approaches make either task faster?</li>
</ul>
<h3 id="binets-fibonacci-number-formula">Binet’s Fibonacci Number Formula</h3>
<div id="" class="spoiler">
<p><a href="http://mathworld.wolfram.com/BinetsFibonacciNumberFormula.html">Binet’s Formula</a> describes the Fibonacci sequence explicitly. With this formula you can calculate any integer in the sequence without relying on the previous values. With Binet’s Formula it is easy to parallelize task 1 above.</p>
<pre><code class="language-javascript">(n) =&gt; (
    <span class="hljs-built_in">Math</span>.pow( (<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">5</span>)) / <span class="hljs-number">2</span> , n) -
    <span class="hljs-built_in">Math</span>.pow( (<span class="hljs-number">1</span> - <span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">5</span>)) / <span class="hljs-number">2</span> , n)
    ) 
    / <span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">5</span>);
</code></pre>
</div>
</div>
<style>
.headless thead {
    display: none;
}
.spoiler h3 {
    margin-top: 0;    
}
.spoiler {
    
    position: relative;
}
.spoiler::after {
    content: "Show Spoiler";
    font-family: "Roboto";
    font-size: 10px;
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
    text-align: center;
    padding: 30px;
    background: black;
    color: white;
    
}
</style>
<script>
var els = document.getElementsByClassName("spoiler");
for (var i = 0; i < els.length; i++) {
    let el = els[i];
    els[i].addEventListener('click', ()=>el.classList.remove("spoiler"));
}

</script>
<h2 id="inherently-serial-vs-embarrassingly-parallel">Inherently Serial vs Embarrassingly Parallel</h2>
<blockquote>
<p>The bearing of a child takes nine months, no matter how many women are assigned.</p>
<p>— Frederick Brooks, The Mythical Man-Month</p>
</blockquote>
<p>GPUs can run shaders very quickly because they are designed for parallel processing.</p>
<p>A problem is <em>parallelizable</em> if it can be divided into parts that can be solved <strong>independently and concurrently</strong>. If a problem is parallelizable, a high number of slow agents can solve it quickly, and a high number of FAST agents can solve it VERY quickly.</p>
<p>A problem is <em>inherently serial</em> if it can’t be divided in this way. If many steps rely on the results of previous steps, you have to run the steps in order and one step cannot start until the previous steps are fully complete.</p>
<h3 id="digging-a-shaft-vs-digging-a-trench">Digging a Shaft vs Digging a Trench</h3>
<p>Consider <a href="https://www.youtube.com/watch?v=bun_WSB9iRw&amp;list=PLAwxTw4SYaPnFKojVQrmyOGFCqHTxfdv2&amp;index=3">digging a hole</a>. To dig the hole faster you need to either 1) dig faster or 2) hire more diggers. If you are already digging as fast as you can, your only option is hiring more diggers.</p>
<p>If you are digging a trench, you are in luck: it is easy for many diggers to work together to dig a trench. Digging the trench is easily parallelizable. A 10 mile trench doesn’t take any longer to dig than 10 foot trench, if you have enough diggers.</p>
<p>If you are digging a shaft, you have a problem: diggers can’t work on the bottom until the top is dug. You have to dig the shaft from the top down. Digging a shaft is inherintly serial. If you hire 100 diggers, 99 of them are going to stand around and watch.</p>
<h3 id="serial-baking-a-cake">Serial: Baking a Cake</h3>
<p>Not all problems can be divided efficiently. Some problems are <a href="https://en.wikipedia.org/wiki/Parallel_algorithm">inherently serial</a>. For example, consider the steps needed to bake a cake.</p>
<ol>
<li>Collect ingredients</li>
<li>Measure ingredients</li>
<li>Combine ingredients</li>
<li>Pour batter into pan</li>
<li>Preheat oven</li>
<li>Bake batter</li>
<li>Cool cake</li>
<li>Ice cake</li>
<li>Decorate cake</li>
</ol>
<p>Most of these steps must be done in order. You can’t measure ingredients you haven’t collected, you can’t combine ingredients before you measure them, you can’t ice a cake you haven’t baked. You <em>can</em> preheat the oven while you collect, measure, and combine the ingredients but that is the only part of the process where working in parallel can help.</p>
<p><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s Law</a></p>
<h3 id="parallel-tinting-an-image">Parallel: Tinting an Image</h3>
<p>In contrast, Tinting an image is <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">embarrasingly parallel</a>. You can divide the image into two parts—maybe the top and bottom—and tint both parts at once. Tinting the top doesn’t rely on tinting the bottom, and tinting the bottom doesn’t rely on tinting the top. Splitting and recombining the parts is very easy. Since there is almost no overhead splitting up the work allows it to be done twice as fast. You can divide the image into 4 parts or 8 parts just as well. Because tinting one pixel doesn’t rely on tinting any other, you can divide the image all the way down to each independent pixel and process them all at once. This is the type of problem that GPUs are specifically designed to solve.</p>
<div id="" class="columns">
<div id="" class="half">
<h4 id="serial">Serial</h4>
<ul>
<li>Three body problem</li>
<li>Computing Pi</li>
<li>Newton’s method</li>
<li>Making a baby</li>
<li>Baking a cake</li>
<li>Digging Shafts</li>
</ul>
</div>
<div id="" class="half">
<h4 id="parallel">Parallel</h4>
<ul>
<li>Monte Carlo simulation</li>
<li>Perlin noise</li>
<li>Ray-tracing</li>
<li>Brute-force password cracking</li>
<li>Tinting images</li>
<li>Digging trenches</li>
</ul>
</div>
</div>
<h2 id="cpus-vs-gpus">CPUs vs GPUs</h2>
<p>For a long time computer designers focused on digging faster. They crammed in more and more transistors, making them smaller and smaller, and clocking them faster and faster. And for a long time <a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore’s law</a> held: the number of transistors in CPUs doubled every two years and so did their speed, more or less. But recently CPU designs have approached physical limits and CPU speed improvements are slowing. This has led to computer designers relying more on hiring more diggers.</p>
<p><a href="https://www.youtube.com/watch?v=ZrJeYFxpUyQ">Mythbusters Leonardo + Leonardo 2.0</a></p>
<p><a href="https://www.youtube.com/watch?v=-P28LKWTzrI">Short Version</a></p>
<h3 id="single-thread-cpu">Single-Thread CPU</h3>
<p>CPUs are designed to solve serial problems very quickly. They have super-high clock-speeds and flexible architectures that allow you to mix data reads, writes, and operations freely.</p>
<p><img src="figures/Single_CPU.svg" alt="cpu"></p>
<h3 id="multi-thread-cpu">Multi-Thread CPU</h3>
<p>Modern CPUs can do more than one thing at a time. Many CPUs have several cores, and the cores can process multiple threads simultaneously.</p>
<p><img src="figures/Multi_CPU_1.svg" alt="cpu"></p>
<p>This allows CPUs to run multiple applications at once, but can’t always speed up a single application if it doesn’t parallelize well.
When problems don’t parallelize well, threads often have to wait on data from other threads.</p>
<p><img src="figures/Multi_CPU_2.svg" alt="cpu"></p>
<h3 id="gpus">GPUs</h3>
<p>GPUs are designed to solve parallel problems very quickly. They tend to have somewhat lower clock-speeds than GPUs but many, many more cores. The GPU is optimized to perform a fixed set of operations on many sets of data simultaniously. The GPU prepares the data, performs the operations, and reads the final results.</p>
<p><img src="figures/GPU.svg" alt="cpu"></p>
<h3 id="latency-vs-throughput">Latency vs Throughput</h3>
<p>CPUs are designed for low latency, they perform one operation at a time as quickly as possible.</p>
<p>GPUs are designed for high throughput, they perform thousands of operations at a time but not as quickly.</p>
<h2 id="shading-vs-drawing">Shading vs Drawing</h2>
<p>So thats how the hardware differs, but how do the programming models differ?</p>
<p>!!! PULL IN /shaders</p>
<h2 id="problem-1-drawing-a-rectangle">Problem 1: Drawing a Rectangle</h2>
<p>rect()</p>
<p>Pixel by Pixel</p>
<p>Shader</p>
<p>Challenge</p>
<h2 id="problem-2-drawing-a-gradient">Problem 2: Drawing a Gradient</h2>
<p>~rect()~</p>
<p>Pixel by Pixel</p>
<p>Shader</p>
<p>Challenge</p>
<h2 id="shader-practicalities">Shader Practicalities</h2>
<p>!!! PULL IN /shaders</p>
<h2 id="live-code-problem-skyline">Live Code Problem: Skyline</h2>
<p>Goal</p>
<p>p5.js</p>
<p>Shader</p>
<h2 id="resources">Resources</h2>
<p>!!! PULL IN /shaders</p>
<p><a href="https://www.youtube.com/watch?v=F620ommtjqk&amp;list=PLAwxTw4SYaPnFKojVQrmyOGFCqHTxfdv2">Udacity: Intro to Parallel Programming</a></p>
<p><a href="https://www.youtube.com/watch?v=bun_WSB9iRw&amp;list=PLAwxTw4SYaPnFKojVQrmyOGFCqHTxfdv2&amp;index=3">Udacity: Digging Holes</a></p>
<p><a href="https://www.youtube.com/watch?v=KdN49C0bxOk&amp;list=PLAwxTw4SYaPnFKojVQrmyOGFCqHTxfdv2&amp;index=17">Udacity: Core GPU Design Tenets</a></p>
<p>[<a href="http://oeis.org/">http://oeis.org/</a>](On-line Encyclopedia of Integer Sequences)</p>
<p>[<a href="https://www.theguardian.com/science/alexs-adventures-in-numberland/2014/oct/07/neil-sloane-the-man-who-loved-only-integer-sequences">https://www.theguardian.com/science/alexs-adventures-in-numberland/2014/oct/07/neil-sloane-the-man-who-loved-only-integer-sequences</a>](Neil Sloane Profile)</p>
<p><a href="https://www.youtube.com/watch?v=hrLjLeGUjio">Mathnet: Case of the Willing Parrot</a></p>
<p><a href="http://visual6502.org/">Visual 6502</a></p>
<p><a href="https://www.youtube.com/watch?v=cNN_tTXABUA">See How a CPU Works</a></p>
</div></div></div><div class="container" id="scroll-out"></div></div></body></html>